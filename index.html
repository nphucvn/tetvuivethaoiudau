<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ƒê√™m Giao Th·ª´a</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial, sans-serif;
  }

  #title {
    position: absolute;
    top: 5%;
    width: 100%;
    text-align: center;
    font-size: 26px;
    color: #ffb6c1;
    text-shadow: 0 0 15px #ff69b4;
  }

  #message {
    position: absolute;
    bottom: 12%;
    width: 100%;
    text-align: center;
    color: #fff;
    font-size: 18px;
    padding: 0 15px;
    line-height: 1.6;
    text-shadow: 0 0 10px rgba(255,255,255,0.6);
  }
</style>
</head>

<body>

<div id="title">‚ú® ƒê√™m Giao Th·ª´a ‚ú®</div>

<div id="message">
  üíñ Ch√∫c Th·∫£o NƒÉm M·ªõi Vui V·∫ª Nh√© üíñ<br/>
  Mong r·∫±ng m·ªçi ni·ªÅm vui, may m·∫Øn v√† nh·ªØng ƒëi·ªÅu d·ªãu d√†ng nh·∫•t<br/>
  s·∫Ω lu√¥n ƒë·∫øn b√™n Th·∫£o trong su·ªët nƒÉm m·ªõi üå∏<br/>
  Ch√∫c Th·∫£o lu√¥n m·ªâm c∆∞·ªùi th·∫≠t nhi·ªÅu v√† h·∫°nh ph√∫c theo c√°ch ri√™ng c·ªßa m√¨nh ‚ú®
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000011);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 12);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const light = new THREE.PointLight(0xffffff, 1.5);
light.position.set(0, 20, 10);
scene.add(light);

// Ground
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(60, 60),
  new THREE.MeshStandardMaterial({ color: 0x040404 })
);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Characters
function createPerson(x) {
  const g = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.CylinderGeometry(0.45, 0.55, 2),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  body.position.y = 1;
  g.add(body);

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.45),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  head.position.y = 2.3;
  g.add(head);

  g.position.x = x;
  scene.add(g);
}
createPerson(-1);
createPerson(1);

// Fireworks system
const fireworks = [];

function launchFirework() {
  const rocket = {
    pos: new THREE.Vector3((Math.random()-0.5)*8, 0, -5),
    vel: new THREE.Vector3(0, Math.random()*0.25+0.35, 0),
    exploded: false
  };
  fireworks.push(rocket);
}

function explode(position) {
  const group = new THREE.Group();
  const particles = [];
  const color = new THREE.Color(Math.random(), Math.random(), Math.random());

  for (let i = 0; i < 150; i++) {
    const p = new THREE.Mesh(
      new THREE.SphereGeometry(0.04),
      new THREE.MeshBasicMaterial({ color })
    );

    const angle1 = Math.random() * Math.PI * 2;
    const angle2 = Math.random() * Math.PI;
    const speed = Math.random() * 0.35 + 0.15;

    p.velocity = new THREE.Vector3(
      Math.cos(angle1) * Math.sin(angle2) * speed,
      Math.cos(angle2) * speed,
      Math.sin(angle1) * Math.sin(angle2) * speed
    );

    p.position.copy(position);
    group.add(p);
    particles.push(p);
  }

  scene.add(group);
  return { group, particles, life: 120 };
}

const explosions = [];

function animate() {
  requestAnimationFrame(animate);

  if (Math.random() < 0.04) launchFirework();

  fireworks.forEach((r, i) => {
    r.pos.add(r.vel);
    if (r.vel.y > 0) r.vel.y -= 0.004;

    if (!r.exploded && r.vel.y <= 0) {
      explosions.push(explode(r.pos.clone()));
      fireworks.splice(i, 1);
    }
  });

  explosions.forEach((e, i) => {
    e.particles.forEach(p => {
      p.position.add(p.velocity);
      p.velocity.y -= 0.005;
    });
    e.life--;
    if (e.life <= 0) {
      scene.remove(e.group);
      explosions.splice(i, 1);
    }
  });

  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
